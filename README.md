# TransactionProcessor Backend Challenge

Cloud-native, serverless, and asynchronous system for processing CNAB files, persisting transactional data, and exposing query capabilities via APIs and a web frontend.

## Overview

This project demonstrates a production-ready backend solution built with modern architectural patterns and best practices. The system processes CNAB (Brazilian bank interchange) files asynchronously, guarantees transactional integrity, and provides a responsive user experience.

This is a **monorepo** containing:

- **Backend**: ASP.NET Core Web API with Clean Architecture and DDD
- **Frontend**: React + TypeScript with custom CSS styling
- **Infrastructure**: Docker Compose orchestration with LocalStack, PostgreSQL, and AWS services

### Key Features

- **Asynchronous file processing** — non-blocking uploads and handling
- **Transactional integrity** — all-or-nothing processing per file
- **Clean Architecture** — Domain-Driven Design principles
- **Serverless-ready backend** — AWS Lambda for scale
- **Robust observability** — structured logging and metrics
- **Clear separation of concerns** — maintainable and testable code

## Tech Stack

### Backend

- **Language**: .NET 8 (C#)
- **Framework**: ASP.NET Core
- **API Framework**: FastEndpoints
- **Architecture**: Clean Architecture + Domain-Driven Design (DDD)
- **ORM**: Entity Framework Core
- **Database**: PostgreSQL 15
- **Cloud Services**: AWS S3, SQS, Cognito (via LocalStack for local dev)
- **Authentication**: OAuth2/JWT
- **Testing**: xUnit, FluentAssertions

### Frontend

- **Framework**: React 19
- **Language**: TypeScript
- **Styling**: Custom CSS (no Bootstrap or jQuery)
- **HTTP Client**: Axios
- **Icons**: Lucide React
- **Build** Tool: Vite

### Infrastructure

- **Cloud Provider**: AWS
- **Compute**: AWS Lambda
- **Messaging**: SQS + DLQ
- **Storage**: S3 (large files)
- **Containerization**: Docker & Docker Compose
- **AWS Emulation (Local)**: LocalStack
- **IaC**: AWS SAM
- **Local Orchestration**: Docker Compose
- **API Documentation**: Swagger/OpenAPI (auto-generated by FastEndpoints)

### Observability

- Structured logs with correlation IDs
- Metrics (Prometheus)
- Dashboards (Grafana)
- Monitoring (CloudWatch in production)

### Testing

- Unit tests: xUnit
- Integration tests
- End-to-end tests (happy path)
- Quality gates enforced

## Project Structure

```
src/
├── backend/
│   ├── TransactionProcessor.Domain/              # Domain layer (entities, enums, value objects)
│   ├── TransactionProcessor.Application/         # Application layer (use cases, DTOs, services)
│   ├── TransactionProcessor.Infrastructure/      # Infrastructure layer (DB, AWS, external services)
│   ├── TransactionProcessor.Api/                 # API layer (endpoints, configuration)
│   ├── TransactionProcessor.Worker/              # Background worker (SQS message processing)
│   ├── tests/
│   │   ├── Unit/
│   │   │   ├── Domain.Tests/          # Domain unit tests
│   │   │   ├── Application.Tests/     # Application use case tests
│   │   │   └── Infrastructure.Tests/  # Infrastructure tests with mocks
│   │   ├── Integration/
│   │   │   ├── Database.Tests/        # Database integration tests
│   │   │   ├── Messaging.Tests/       # SQS messaging tests
│   │   │   ├── Storage.Tests/         # S3 storage tests
│   │   │   └── Api.Tests/             # API endpoint tests
│   │   └── E2E/
│   │       └── HappyPath.Tests/       # End-to-end happy path tests
│   ├── Dockerfile.api                  # Docker image for API
│   ├── Dockerfile.worker               # Docker image for Worker
│   └── TransactionProcessor.sln                  # Solution file
├── frontend/
│   ├── src/
│   │   ├── components/                 # React components
│   │   ├── services/                   # API service layer
│   │   ├── types/                      # TypeScript types
│   │   ├── App.tsx                     # Main app component
│   │   └── main.tsx                    # Entry point
│   ├── Dockerfile                      # Docker image for frontend
│   ├── nginx.conf                      # Nginx configuration
│   └── vite.config.ts                  # Vite configuration
├── infra/
│   └── localstack-init/                # LocalStack initialization scripts
├── docs/                               # Documentation files
├── docker-compose.yml                  # Docker Compose orchestration
└── README.md                           # This file
```

## CNAB File Format

The system processes CNAB files with the following structure:

| Field | Start | End | Length | Description |
|-------|-------|-----|--------|-------------|
| Type | 1 | 1 | 1 | Transaction type (1-9) |
| Date | 2 | 9 | 8 | Occurrence date (YYYYMMDD) |
| Amount | 10 | 19 | 10 | Transaction amount (divide by 100.00) |
| CPF | 20 | 30 | 11 | Recipient CPF |
| Card | 31 | 42 | 12 | Card used in transaction |
| Time | 43 | 48 | 6 | Occurrence time (HHMMSS) |
| Store Owner | 49 | 62 | 14 | Store representative name |
| Store Name | 63 | 81 | 19 | Store name |

### Transaction Types

| Type | Description | Nature | Sign |
|------|-------------|--------|------|
| 1 | Debit | Inflow | + |
| 2 | Bank Slip (Boleto) | Outflow | - |
| 3 | Financing | Outflow | - |
| 4 | Credit | Inflow | + |
| 5 | Loan Receipt | Inflow | + |
| 6 | Sales | Inflow | + |
| 7 | TED Receipt | Inflow | + |
| 8 | DOC Receipt | Inflow | + |
| 9 | Rent | Outflow | - |

## Quick Start

### Prerequisites

- Docker and Docker Compose
- .NET 8 SDK (for local dev without Docker)
- Node.js 22+ (for frontend dev without Docker)
- pnpm or npm (for frontend packages)

### Local Development with Docker Compose

1. **Clone the repository** (if applicable):
   ```bash
   git clone <repository-url>
   cd src
   ```

2. **Build and start all services**:
   ```bash
   docker-compose up --build
   ```

   This command will:
   - Start PostgreSQL database
   - Start LocalStack (AWS emulation)
   - Initialize AWS resources (S3 bucket, SQS queues)
   - Build and start the backend API
   - Build and start the background worker
   - Build and start the frontend

3. **Access the application**:
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:5000
   - Swagger/OpenAPI: http://localhost:5000/swagger

4. **Stop all services**:
   ```bash
   docker-compose down
   ```

### Local Development without Docker

#### Backend API

1. **Navigate to backend directory**:
   ```bash
   cd src/backend
   ```

2. **Restore NuGet packages**:
   ```bash
   dotnet restore
   ```

3. **Apply database migrations**:
   ```bash
   dotnet ef database update --project TransactionProcessor.Infrastructure --startup-project TransactionProcessor.Api
   ```

4. **Start the API**:
   ```bash
   dotnet run --project TransactionProcessor.Api
   ```

   API available at http://localhost:5000

#### Background Worker

1. **In a new terminal, navigate to backend directory**:
   ```bash
   cd src/backend
   ```

2. **Start the worker**:
   ```bash
   dotnet run --project TransactionProcessor.Worker
   ```

#### Frontend

1. **Navigate to frontend directory**:
   ```bash
   cd src/frontend
   ```

2. **Install dependencies**:
   ```bash
   pnpm install
   ```

3. **Start dev server**:
   ```bash
   pnpm dev
   ```

   Frontend available at http://localhost:5173

## API Endpoints

### Upload CNAB File

**POST** `/api/files/v1/upload`

Uploads a CNAB file for processing. The file is stored in S3 and a message is enqueued in SQS for asynchronous processing.

**Request**:
```
Content-Type: multipart/form-data
Body: file (binary)
```

**Response**:
```json
{
  "success": true,
  "message": "CNAB file uploaded and queued for processing."
}
```

### List Transactions

GET `/api/transactions/v1?storeName={storeName}&startDate={startDate}&endDate={endDate}`

Retrieves transactions with optional filters by store name and date range.

Query Parameters:
- `storeName` (optional): Filter by store name
- `startDate` (optional): From date (ISO 8601)
- `endDate` (optional): To date (ISO 8601)

**Response**:
```json
[
   {
      "id": "uuid",
      "type": 1,
      "date": "2024-01-13T00:00:00Z",
      "value": 100.00,
      "cpf": "12345678901",
      "card": "123456789012",
      "time": "10:30:00",
      "storeOwner": "John Doe",
      "storeName": "Store A",
      "signedValue": 100.00
   }
]
```

### List Stores with Balances

**GET** `/api/stores/v1`

Retrieves all stores with their computed balances.

**Response**:
```json
[
   {
      "id": "uuid",
      "name": "Store A",
      "owner": "John Doe",
      "balance": 1500.50
   }
]
```

## Asynchronous Processing Flow

1. **User uploads CNAB file** via frontend
2. **Frontend sends file to backend API** (POST /api/files/v1/upload)
3. **Backend validates file structure** and stores in S3
4. **SQS message enqueued** with S3 file reference
5. **Background worker polls SQS** for messages
6. **Worker downloads file from S3** and parses CNAB records
7. **Database transaction opened** for atomicity
8. **Records validated and persisted** to PostgreSQL
9. **Transaction committed or rolled back** based on validation
10. **Processing status updated** and results exposed via API
11. **Failed messages sent to DLQ** for manual review

## Core Features

- **File Upload**: Upload CNAB files via web interface
- **Asynchronous Processing**: Non-blocking processing with SQS
- **Transaction Management**: All-or-nothing processing per file
- **Balance Calculation per Store**: Automatic balance calculation per store
- **Query Capabilities**: Transaction filtering by store and date range
- **Real-time Status**: Processing status tracking

## Documentation Navigation

Organized by audience, each document has a clear responsibility:

### Business Stakeholders
- [docs/business-rules.md](docs/business-rules.md) — Functional requirements and business logic

### Developers
- [docs/architecture.md](docs/architecture.md) — System overview and components
- [docs/backend.md](docs/backend.md) — Backend implementation details
- [docs/frontend.md](docs/frontend.md) — Frontend implementation details
- [docs/database.md](docs/database.md) — Schema and design decisions
- [docs/async-processing.md](docs/async-processing.md) — Asynchronous processing flow

### Technical Reviewers
- [docs/security.md](docs/security.md) — Security implementation and considerations
- [docs/observability.md](docs/observability.md) — Logging, metrics, monitoring
- [docs/testing-strategy.md](docs/testing-strategy.md) — Testing approach and coverage
- [docs/decisions-and-tradeoffs.md](docs/decisions-and-tradeoffs.md) — Architectural decisions and rationale

## Testing

The project includes comprehensive tests:

### Unit Tests

```bash
cd src/backend
dotnet test
```

### Integration Tests

Verify interactions with database and API endpoints.

### End-to-End Tests

Cover the happy path: upload → processing → query.

Quality gates enforced — builds fail on test failures.

See [docs/testing-strategy.md](docs/testing-strategy.md) for details.

## Observability

The system includes:

### Logging

- **Structured logging** with correlation IDs
- **Context-rich entries** for debugging
- **Log levels**: Information, Warning, Error

### Metrics

- Processing duration
- Success/failure counts
- Queue depth (SQS)

### Monitoring (Production)

- Prometheus for metrics collection
- Grafana for dashboards
- CloudWatch for managed monitoring

See [docs/observability.md](docs/observability.md) for details.

## Security

### Authentication and Authorization

- **JWT-based authentication** with token validation
- **OAuth2 integration** with AWS Cognito (production) or LocalStack (local dev)
- **Role-based access control (RBAC)** planned for improvements

### Data Protection

- **HTTPS/TLS** in transit (configured via reverse proxy in production)
- **Parameterized queries** via EF Core (SQL injection prevention)
- **Input validation and sanitization** across endpoints
- **Secure token storage with** HttpOnly cookies (frontend)

### OWASP Compliance

Addresses key OWASP Top 10 risks:
- **A01:2021 – Broken Access Control**: Token validation on every request
- **A02:2021 – Cryptographic Failures**: Strong signing algorithms (RS256)
- **A03:2021 – Injection**: Parameterized queries via EF Core
- **A07:2021 – Identification and Authentication Failures**: Token expiration and refresh mechanisms

**Note**: For testing/demo, LocalStack Cognito is used locally. See [docs/security.md](docs/security.md) for production considerations, known JWT vulnerabilities, and OWASP compliance.

## Deployment

### Local Deployment

Use Docker Compose (see "Quick Start" section above).

### Production Deployment

For production, the system is designed to run on AWS:

1. **API**: AWS Lambda with API Gateway
2. **Worker**: AWS Lambda triggered by SQS
3. **Database**: AWS RDS PostgreSQL
4. **Storage**: AWS S3
5. **Messaging**: AWS SQS with DLQ
6. **Authentication**: AWS Cognito
7. **Monitoring**: AWS CloudWatch

Migration from LocalStack to AWS requires:
- Update configuration to use real AWS endpoints
- Provision AWS resources (Lambda, RDS, S3, SQS, Cognito)
- Configure IAM roles and policies
- Set production environment variables

## Troubleshooting

### Database Connection Issues

If the backend cannot connect to the database:

1. Check if the PostgreSQL container is running: `docker-compose ps`
2. Verify database credentials in `appsettings.json`
3. Check network connectivity: `docker-compose logs db`

### LocalStack Issues

If AWS services are not available:

1. Check the LocalStack container: `docker-compose ps`
2. Check the initialization script: `docker-compose logs localstack`
3. Ensure the S3 bucket and SQS queues were created

### Frontend to API Connection Issues

If the frontend cannot reach the backend:

1. Check if the backend API is running: `docker-compose ps`
2. Verify CORS configuration in `Program.cs`
3. Check the API base URL in `frontend/src/services/api.ts`

## Explicit Non-Goals

This project deliberately avoids:
- Microservices explosion
- Event sourcing
- Heavy CQRS frameworks
- Premature optimization

All components exist to demonstrate real-world scalability patterns, not complexity for its own sake.

See [Decisions and Trade-offs](docs/decisions-and-tradeoffs.md) for detailed rationale.

## Future Evolution (Out of Scope)

While this project demonstrates production-ready patterns, the following is explicitly out of scope:
- Multi-region deployment
- Advanced event sourcing
- Complex CQRS patterns
- Microservices decomposition

These can be added based on real business needs.

## Contributing

This is a challenge project. For questions or clarifications, consult the [Decisions and Trade-offs](docs/decisions-and-tradeoffs.md) document.

To contribute code:

1. Create a feature branch: `git checkout -b feature/your-feature`
2. Commit your changes: `git commit -am 'Add your feature'`
3. Push to the branch: `git push origin feature/your-feature`
4. Submit a pull request

## License

MIT License. See LICENSE file for details.

---

For issues, questions, or suggestions, contact the development team or open an issue in the repository.

This project is part of the TransactionProcessor Backend Challenge and is provided for educational and evaluation purposes.

## Support

For issues, questions, or suggestions, contact the development team or open an issue in the repository.

---

**Last Updated**: January 14, 2026  
**Version**: 1.0.0
