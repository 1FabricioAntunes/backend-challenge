using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using TransactionProcessor.Domain.Entities;
using TransactionProcessor.Infrastructure.Repositories;
using TransactionProcessor.Tests.Integration.Fixtures;
using Xunit;

namespace TransactionProcessor.Tests.Integration.Repositories;

/// <summary>
/// Integration tests for TransactionRepository using PostgreSQL Testcontainers.
/// 
/// Tests verify:
/// - CRUD operations with BIGSERIAL primary key
/// - Query with filters (date range, store ID)
/// - Eager loading of related entities (Store, TransactionType)
/// - Batch insert operations for file processing
/// - Idempotency checks with GetFirstByFileAndStoreAsync
/// </summary>
[Collection("RepositoryIntegration")]
public class TransactionRepositoryIntegrationTests : IAsyncLifetime
{
    private readonly RepositoryIntegrationFixture _fixture;

    public TransactionRepositoryIntegrationTests()
    {
        _fixture = new RepositoryIntegrationFixture();
    }

    public async Task InitializeAsync()
    {
        await _fixture.InitializeAsync();
    }

    public async Task DisposeAsync()
    {
        await _fixture.DisposeAsync();
    }

    #region Helper Methods

    private async Task<(Store Store, Domain.Entities.File File)> CreateStoreAndFileAsync()
    {
        await using var context = _fixture.CreateDbContext();
        
        // Note: Store name max 19 chars, OwnerName max 14 chars
        var shortId = Guid.NewGuid().ToString("N").Substring(0, 8);
        var store = RepositoryIntegrationFixture.CreateStore(
            name: $"TStore {shortId}",
            ownerName: $"Owner {shortId}"
        );
        await context.Stores.AddAsync(store);

        var file = RepositoryIntegrationFixture.CreateFile($"test_{shortId}.txt");
        await context.Files.AddAsync(file);

        await context.SaveChangesAsync();
        return (store, file);
    }

    #endregion

    #region AddAsync Tests

    [Fact]
    public async Task AddAsync_ValidTransaction_PersistsWithAutoGeneratedId()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transaction = RepositoryIntegrationFixture.CreateTransaction(
            file.Id,
            store.Id,
            typeCode: "4",
            amount: 10000m
        );

        // Act
        await repository.AddAsync(transaction);

        // Assert
        transaction.Id.Should().BeGreaterThan(0); // BIGSERIAL auto-generated

        await using var verifyContext = _fixture.CreateDbContext();
        var persisted = await verifyContext.Transactions
            .AsNoTracking()
            .FirstOrDefaultAsync(t => t.Id == transaction.Id);

        persisted.Should().NotBeNull();
        persisted!.FileId.Should().Be(file.Id);
        persisted.StoreId.Should().Be(store.Id);
        persisted.TransactionTypeCode.Should().Be("4");
        persisted.Amount.Should().Be(10000m);
        persisted.CPF.Should().Be("12345678901");
        persisted.Card.Should().Be("123456789012");

        await context.DisposeAsync();
    }

    [Fact]
    public async Task AddAsync_NullTransaction_ThrowsArgumentNullException()
    {
        // Arrange
        var (repository, context) = _fixture.CreateTransactionRepository();

        // Act
        Func<Task> act = () => repository.AddAsync(null!);

        // Assert
        await act.Should().ThrowAsync<ArgumentNullException>()
            .WithParameterName("transaction");

        await context.DisposeAsync();
    }

    [Fact]
    public async Task AddAsync_InvalidFileId_ThrowsDbUpdateException()
    {
        // Arrange
        var (store, _) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transaction = RepositoryIntegrationFixture.CreateTransaction(
            Guid.NewGuid(), // Non-existing file ID
            store.Id,
            typeCode: "4",
            amount: 5000m
        );

        // Act
        Func<Task> act = () => repository.AddAsync(transaction);

        // Assert
        await act.Should().ThrowAsync<DbUpdateException>();

        await context.DisposeAsync();
    }

    #endregion

    #region AddRangeAsync Tests

    [Fact]
    public async Task AddRangeAsync_MultipleTransactions_PersistsAllInBatch()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transactions = new List<Transaction>();
        for (int i = 0; i < 100; i++)
        {
            transactions.Add(RepositoryIntegrationFixture.CreateTransaction(
                file.Id,
                store.Id,
                typeCode: ((i % 9) + 1).ToString(),
                amount: 1000m + (i * 10)
            ));
        }

        // Act
        await repository.AddRangeAsync(transactions);

        // Assert
        await using var verifyContext = _fixture.CreateDbContext();
        var persistedCount = await verifyContext.Transactions
            .CountAsync(t => t.FileId == file.Id);

        persistedCount.Should().Be(100);

        // Verify all have auto-generated IDs
        transactions.Should().OnlyContain(t => t.Id > 0);

        await context.DisposeAsync();
    }

    [Fact]
    public async Task AddRangeAsync_NullCollection_ThrowsArgumentNullException()
    {
        // Arrange
        var (repository, context) = _fixture.CreateTransactionRepository();

        // Act
        Func<Task> act = () => repository.AddRangeAsync(null!);

        // Assert
        await act.Should().ThrowAsync<ArgumentNullException>()
            .WithParameterName("transactions");

        await context.DisposeAsync();
    }

    [Fact]
    public async Task AddRangeAsync_EmptyCollection_SucceedsWithoutError()
    {
        // Arrange
        var (repository, context) = _fixture.CreateTransactionRepository();

        // Act
        Func<Task> act = () => repository.AddRangeAsync(new List<Transaction>());

        // Assert
        await act.Should().NotThrowAsync();

        await context.DisposeAsync();
    }

    #endregion

    #region GetByIdAsync Tests

    [Fact]
    public async Task GetByIdAsync_ExistingTransaction_ReturnsWithRelatedEntities()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transaction = RepositoryIntegrationFixture.CreateTransaction(
            file.Id,
            store.Id,
            typeCode: "6", // Vendas (Income)
            amount: 25000m
        );
        await repository.AddAsync(transaction);

        // Act
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = await readRepository.GetByIdAsync(transaction.Id);

        // Assert
        result.Should().NotBeNull();
        result!.Id.Should().Be(transaction.Id);
        result.Amount.Should().Be(25000m);
        
        // Verify eager loading of Store and File
        result.Store.Should().NotBeNull();
        result.Store!.Id.Should().Be(store.Id);
        
        result.File.Should().NotBeNull();
        result.File!.Id.Should().Be(file.Id);
        
        // Note: TransactionType navigation may not load due to FK shadow property mapping
        // The TransactionTypeCode is correctly stored as "6"
        result.TransactionTypeCode.Should().Be("6");

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    [Fact]
    public async Task GetByIdAsync_NonExistingTransaction_ReturnsNull()
    {
        // Arrange
        var (repository, context) = _fixture.CreateTransactionRepository();

        // Act
        var result = await repository.GetByIdAsync(999999L);

        // Assert
        result.Should().BeNull();

        await context.DisposeAsync();
    }

    #endregion

    #region GetByFileIdAsync Tests

    [Fact]
    public async Task GetByFileIdAsync_ExistingFile_ReturnsAllTransactionsOrderedByDate()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var baseDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(-10));
        var transactions = new List<Transaction>
        {
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "4", 1000m, 
                baseDate.AddDays(5), TimeOnly.FromTimeSpan(TimeSpan.FromHours(10))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "5", 2000m, 
                baseDate.AddDays(1), TimeOnly.FromTimeSpan(TimeSpan.FromHours(14))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "6", 3000m, 
                baseDate.AddDays(3), TimeOnly.FromTimeSpan(TimeSpan.FromHours(9))),
        };
        await repository.AddRangeAsync(transactions);

        // Act
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = (await readRepository.GetByFileIdAsync(file.Id)).ToList();

        // Assert
        result.Should().HaveCount(3);
        
        // Verify ordering by date then time
        result[0].TransactionDate.Should().Be(baseDate.AddDays(1));
        result[1].TransactionDate.Should().Be(baseDate.AddDays(3));
        result[2].TransactionDate.Should().Be(baseDate.AddDays(5));

        // Verify eager loading of Store
        result.Should().OnlyContain(t => t.Store != null);

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    [Fact]
    public async Task GetByFileIdAsync_NonExistingFile_ReturnsEmptyCollection()
    {
        // Arrange
        var (repository, context) = _fixture.CreateTransactionRepository();

        // Act
        var result = await repository.GetByFileIdAsync(Guid.NewGuid());

        // Assert
        result.Should().BeEmpty();

        await context.DisposeAsync();
    }

    #endregion

    #region GetByStoreIdAsync Tests

    [Fact]
    public async Task GetByStoreIdAsync_WithoutDateFilter_ReturnsAllStoreTransactions()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transactions = RepositoryIntegrationFixture.CreateTransactionsForBalanceTest(file.Id, store.Id);
        await repository.AddRangeAsync(transactions);

        // Act
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = (await readRepository.GetByStoreIdAsync(store.Id)).ToList();

        // Assert
        result.Should().HaveCount(6);
        result.Should().OnlyContain(t => t.StoreId == store.Id);

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    [Fact]
    public async Task GetByStoreIdAsync_WithDateRange_FiltersCorrectly()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var baseDate = DateTime.UtcNow.AddDays(-30);
        var transactions = new List<Transaction>
        {
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "4", 1000m, 
                DateOnly.FromDateTime(baseDate.AddDays(5))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "5", 2000m, 
                DateOnly.FromDateTime(baseDate.AddDays(10))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "6", 3000m, 
                DateOnly.FromDateTime(baseDate.AddDays(15))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "7", 4000m, 
                DateOnly.FromDateTime(baseDate.AddDays(20))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "8", 5000m, 
                DateOnly.FromDateTime(baseDate.AddDays(25))),
        };
        await repository.AddRangeAsync(transactions);

        // Act - Filter from day 10 to day 20
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = (await readRepository.GetByStoreIdAsync(
            store.Id,
            baseDate.AddDays(10),
            baseDate.AddDays(20)
        )).ToList();

        // Assert
        result.Should().HaveCount(3);
        result.Should().OnlyContain(t => 
            t.TransactionDate >= DateOnly.FromDateTime(baseDate.AddDays(10)) &&
            t.TransactionDate <= DateOnly.FromDateTime(baseDate.AddDays(20)));

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    [Fact]
    public async Task GetByStoreIdAsync_WithStartDateOnly_FiltersFromDate()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var baseDate = DateTime.UtcNow.AddDays(-20);
        var transactions = new List<Transaction>
        {
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "4", 1000m, 
                DateOnly.FromDateTime(baseDate.AddDays(5))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "5", 2000m, 
                DateOnly.FromDateTime(baseDate.AddDays(10))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "6", 3000m, 
                DateOnly.FromDateTime(baseDate.AddDays(15))),
        };
        await repository.AddRangeAsync(transactions);

        // Act
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = (await readRepository.GetByStoreIdAsync(
            store.Id,
            startDate: baseDate.AddDays(10),
            endDate: null
        )).ToList();

        // Assert
        result.Should().HaveCount(2);
        result.Should().OnlyContain(t => t.TransactionDate >= DateOnly.FromDateTime(baseDate.AddDays(10)));

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    [Fact]
    public async Task GetByStoreIdAsync_WithEndDateOnly_FiltersUntilDate()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var baseDate = DateTime.UtcNow.AddDays(-20);
        var transactions = new List<Transaction>
        {
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "4", 1000m, 
                DateOnly.FromDateTime(baseDate.AddDays(5))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "5", 2000m, 
                DateOnly.FromDateTime(baseDate.AddDays(10))),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "6", 3000m, 
                DateOnly.FromDateTime(baseDate.AddDays(15))),
        };
        await repository.AddRangeAsync(transactions);

        // Act
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = (await readRepository.GetByStoreIdAsync(
            store.Id,
            startDate: null,
            endDate: baseDate.AddDays(10)
        )).ToList();

        // Assert
        result.Should().HaveCount(2);
        result.Should().OnlyContain(t => t.TransactionDate <= DateOnly.FromDateTime(baseDate.AddDays(10)));

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    #endregion

    #region GetFirstByFileAndStoreAsync Tests

    [Fact]
    public async Task GetFirstByFileAndStoreAsync_ExistingCombination_ReturnsTransaction()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transactions = new List<Transaction>
        {
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "4", 1000m),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "5", 2000m),
        };
        await repository.AddRangeAsync(transactions);

        // Act
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = await readRepository.GetFirstByFileAndStoreAsync(file.Id, store.Id);

        // Assert
        result.Should().NotBeNull();
        result!.FileId.Should().Be(file.Id);
        result.StoreId.Should().Be(store.Id);

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    [Fact]
    public async Task GetFirstByFileAndStoreAsync_NonExistingCombination_ReturnsNull()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();

        // Act - Use different file ID
        var result = await repository.GetFirstByFileAndStoreAsync(Guid.NewGuid(), store.Id);

        // Assert
        result.Should().BeNull();

        await context.DisposeAsync();
    }

    [Fact]
    public async Task GetFirstByFileAndStoreAsync_IdempotencyCheck_PreventsDuplicateProcessing()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();

        // First check - should return null (not processed)
        var firstCheck = await repository.GetFirstByFileAndStoreAsync(file.Id, store.Id);
        firstCheck.Should().BeNull();

        // Process transactions
        var transaction = RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id);
        await repository.AddAsync(transaction);

        // Second check - should return transaction (already processed)
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var secondCheck = await readRepository.GetFirstByFileAndStoreAsync(file.Id, store.Id);
        secondCheck.Should().NotBeNull();

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    #endregion

    #region Balance Calculation Tests

    [Fact]
    public async Task GetByStoreIdAsync_ReturnsTransactionsWithCorrectTypeCode()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transactions = RepositoryIntegrationFixture.CreateTransactionsForBalanceTest(file.Id, store.Id);
        await repository.AddRangeAsync(transactions);

        // Act
        var (readRepository, readContext) = _fixture.CreateTransactionRepository();
        var result = (await readRepository.GetByStoreIdAsync(store.Id)).ToList();

        // Assert - Verify transaction type codes are correctly stored
        result.Should().HaveCount(6);
        
        // Calculate balance using type codes directly
        // Credit types (4,5,6,7,8): positive balance impact
        // Debit types (1,2,3,9): negative balance impact
        decimal calculatedBalance = 0m;
        foreach (var t in result)
        {
            var isDebit = t.TransactionTypeCode == "1" || t.TransactionTypeCode == "2" || 
                          t.TransactionTypeCode == "3" || t.TransactionTypeCode == "9";
            var signedAmount = isDebit ? -(t.Amount / 100m) : (t.Amount / 100m);
            calculatedBalance += signedAmount;
        }

        // Expected: 100 + 50 + 30 - 20 - 15 - 5 = 140.00
        calculatedBalance.Should().Be(140.00m);

        await context.DisposeAsync();
        await readContext.DisposeAsync();
    }

    #endregion

    #region Cascade Delete Tests

    [Fact]
    public async Task DeletingFile_CascadeDeletesTransactions()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transactions = new List<Transaction>
        {
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "4", 1000m),
            RepositoryIntegrationFixture.CreateTransaction(file.Id, store.Id, "5", 2000m),
        };
        await repository.AddRangeAsync(transactions);

        // Verify transactions exist
        await using var verifyContext1 = _fixture.CreateDbContext();
        var countBefore = await verifyContext1.Transactions.CountAsync(t => t.FileId == file.Id);
        countBefore.Should().Be(2);

        // Act - Delete the file
        await using var deleteContext = _fixture.CreateDbContext();
        var fileToDelete = await deleteContext.Files.FirstAsync(f => f.Id == file.Id);
        deleteContext.Files.Remove(fileToDelete);
        await deleteContext.SaveChangesAsync();

        // Assert - Transactions should be cascade deleted
        await using var verifyContext2 = _fixture.CreateDbContext();
        var countAfter = await verifyContext2.Transactions.CountAsync(t => t.FileId == file.Id);
        countAfter.Should().Be(0);

        await context.DisposeAsync();
    }

    #endregion

    #region Performance Tests

    [Fact]
    public async Task AddRangeAsync_LargeBatch_CompletesInReasonableTime()
    {
        // Arrange
        var (store, file) = await CreateStoreAndFileAsync();
        var (repository, context) = _fixture.CreateTransactionRepository();
        
        var transactions = Enumerable.Range(1, 1000)
            .Select(i => RepositoryIntegrationFixture.CreateTransaction(
                file.Id,
                store.Id,
                typeCode: ((i % 9) + 1).ToString(),
                amount: 1000m + i
            ))
            .ToList();

        // Act
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        await repository.AddRangeAsync(transactions);
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(10000); // Should complete in < 10 seconds

        await using var verifyContext = _fixture.CreateDbContext();
        var count = await verifyContext.Transactions.CountAsync(t => t.FileId == file.Id);
        count.Should().Be(1000);

        await context.DisposeAsync();
    }

    #endregion
}
